#' Calculate Matched Survival Data using Incidence Density Matching
#'
#' Orchestrates the process of fetching data, combining demographics/observation periods,
#' applying washout, defining cohorts, performing matching, calculating survival,
#' and returning results for multiple exposure-outcome pairs using Incidence
#' Density Matching principles. It calls specific helper functions for each step.
#'
#' @param selectedExposureIds A numeric vector of concept IDs for exposure conditions.
#' @param selectedOutcomeIds A numeric vector of concept IDs for outcome conditions.
#' @param cdm A CDM reference object created by `CDMConnector::cdmFromCon`.
#' @param conceptLabelLookup A tibble or data frame used as a lookup table to
#'   find human-readable labels based on concept IDs. Must contain columns
#'   `concept_id` and `concept_name_id` (where `concept_name_id` holds the label).
#'   Used for labeling results.
#' @param matchRatio The target number of controls to match to each exposed person.
#' @param washoutYears The washout period in years applied relative to each outcome.
#' @param session The Shiny session object, passed down to helper functions
#'   that require it for displaying notifications.
#'
#' @return A list where names are unique keys for each processed exposure-outcome
#'   pair (e.g., "pair_exposureID_outcomeID"). Each element of the list is itself
#'   a list containing:
#'   \describe{
#'     \item{survivalData}{The tibble generated by `calculatePairSurvival` for the pair.}
#'     \item{exposureId}{Numeric ID of the exposure.}
#'     \item{outcomeId}{Numeric ID of the outcome.}
#'     \item{exposureLabel}{Character label for the exposure (from `conceptLabelLookup`).}
#'     \item{outcomeLabel}{Character label for the outcome (from `conceptLabelLookup`).}
#'     \item{nExposedIncludedInMatching}{Count of exposed individuals after checking for prior outcomes.}
#'     \item{nExposedMatched}{Count of exposed individuals successfully matched to >=1 control.}
#'     \item{nUnexposedMatched}{Total count of matched unexposed controls.}
#'     \item{nTotalPersonsInAnalysis}{Total number of rows (persons) in the final `survivalData` for the pair.}
#'   }
#' Returns `NULL` if a major initial error occurs (e.g., fetching data fails,
#' initial cohort is empty) or if no exposure-outcome pairs yield valid results.
#'
calculateMatchedSurvivalData <- function(selectedExposureIds,
                                         selectedOutcomeIds,
                                         cdm,
                                         conceptLabelLookup,
                                         matchRatio = 4,
                                         washoutYears = 2,
                                         session) {
  
  # --- 1. Input Validation ---
  if (missing(selectedExposureIds) || missing(selectedOutcomeIds) || missing(cdm) || missing(conceptLabelLookup) || missing(session)) {
    stop("calculateMatchedSurvivalData: Missing required arguments.")
  }
  if (!is.numeric(selectedExposureIds) || !is.numeric(selectedOutcomeIds)) stop("selectedExposureIds and selectedOutcomeIds must be numeric vectors.")
  if (!is.numeric(matchRatio) || matchRatio < 1) stop("matchRatio must be a positive integer.")
  if (!is.numeric(washoutYears) || washoutYears < 0) stop("washoutYears must be a non-negative number.")
  if (!is.data.frame(conceptLabelLookup) || !("concept_id" %in% names(conceptLabelLookup) && "concept_name_id" %in% names(conceptLabelLookup))) {
    stop("'conceptLabelLookup' must be a data frame/tibble with 'concept_id' and 'concept_name_id' columns.")
  }
  
  # --- Initial Setup ---
  procMainId <- "proc_main_survival_calc"
  showNotification("Starting Incidence Density Matching Analysis...", duration = NA, type="message", id = procMainId, session = session)
  # Ensure the main notification is removed when the function exits
  on.exit(removeNotification(id = procMainId, session = session), add = TRUE)
  
  
  # --- 2. Fetch Required Input Data ---
  allConceptIdsToFetch <- unique(c(selectedExposureIds, selectedOutcomeIds))

  baseDataResult <- fetchDataForSurvAnalysis(cdm, allConceptIdsToFetch, session = session)
  
  # Check for critical errors during data fetching
  # Check if the list itself is NULL or if key components are NULL/empty
  if (is.null(baseDataResult) || is.null(baseDataResult$demographics) || is.null(baseDataResult$obsPeriods) ||
      nrow(baseDataResult$demographics) == 0 || nrow(baseDataResult$obsPeriods) == 0 ) {
    showNotification("Critical error fetching base data or base data empty. Cannot proceed.", type="error", duration=10, session=session)
    return(NULL)
  }
  demographicsBase <- baseDataResult$demographics
  obsPeriods <- baseDataResult$obsPeriods
  allConditionFirstDates <- baseDataResult$conditionDates
  
  
  # --- 3. Create the Full Base Cohort ---
  # Combine demographics and observation periods
  fullCohortBase <- demographicsBase %>%
    dplyr::inner_join(obsPeriods, by = "person_id")
  
  if (is.null(fullCohortBase) || nrow(fullCohortBase) == 0) {
    showNotification("Initial cohort base is empty after combining demographics and observation periods. Cannot proceed.", type = "error", duration=10, session=session)
    return(NULL)
  }
  
  
  # --- 4. Initialize Results List ---
  resultsList <- list()
  
  # --- 5. Outer Loop: Iterate through each selected Outcome condition ---
  for (outcomeId in selectedOutcomeIds) {
    outcomeIdStr <- as.character(outcomeId)
    prepOutcomeNotifId <- paste0("prep_outcome_", outcomeIdStr)
    showNotification(paste("Preparing analysis for Outcome ID:", outcomeIdStr), duration = NA, id = prepOutcomeNotifId, session = session)
    
    # --- 5a. Filter by Washout & Get Outcome Dates ---

    washoutFilterResult <- filterByWashoutAndGetOutcomeDates(
      cohortBase = fullCohortBase,
      allConditionDates = allConditionFirstDates,
      outcomeId = outcomeId,
      washoutYears = washoutYears,
      session = session
    )
    
    cohortBaseForOutcome <- washoutFilterResult$cohortEligible
    outcomeDatesCurrentOutcome <- washoutFilterResult$outcomeDates
    
    # Check if cohort is usable after washout
    if (is.null(cohortBaseForOutcome) || nrow(cohortBaseForOutcome) == 0) {
      removeNotification(id = prepOutcomeNotifId, session = session)
      next # Skip to the next outcomeId
    }
    
    showNotification(paste("Eligible persons for Outcome ID", outcomeIdStr, "after washout:", nrow(cohortBaseForOutcome)), type="message", duration=3, session = session)
    
    # Prepare potential controls pool base for this specific outcome loop
    controlsPoolBaseOutcome <- cohortBaseForOutcome %>%
      dplyr::select(dplyr::all_of(c("person_id", "year_of_birth", "gender_concept_id", "obs_start_date", "obs_end_date"))) %>%
      dplyr::left_join(outcomeDatesCurrentOutcome, by = "person_id") # Add this outcome's date
    
    removeNotification(id = prepOutcomeNotifId, session = session) # Done preparing for this outcome
    
    # --- 6. Inner Loop: Iterate through each selected Exposure condition ---
    for (exposureId in selectedExposureIds) {
      exposureIdStr <- as.character(exposureId)
      uniquePairKey <- paste0("pair_", exposureIdStr, "_", outcomeIdStr)
      procPairNotifId <- paste0("proc_pair_", uniquePairKey)
      
      on.exit(removeNotification(id = procPairNotifId, session = session), add = TRUE, after = FALSE) # Ensure removal on exit from this iteration block
      showNotification(paste("Processing Exposure ID:", exposureIdStr, "for Outcome ID:", outcomeIdStr), duration = NA, id = procPairNotifId, session = session)
      
      # --- 6a. Define Exposed Cohort for this Pair ---
      exposedResult <- defineExposedCohortForPair(
        cohortBaseForOutcome = cohortBaseForOutcome,
        allConditionFirstDates = allConditionFirstDates,
        outcomeDatesCurrentOutcome = outcomeDatesCurrentOutcome,
        exposureId = exposureId,
        session = session
      )
      
      exposedCohortDefinition <- exposedResult$exposed
      exposureDatesCurrentExposure <- exposedResult$exposureDates
      
      # Check if any exposed individuals were found
      if (is.null(exposedCohortDefinition) || nrow(exposedCohortDefinition) == 0) {
        removeNotification(id = procPairNotifId, session = session)
        on.exit(NULL) # Clear the specific on.exit for this pair notification
        next # Skip to next exposureId
      }
      
      nExposedIdentifiedInitial <- nrow(exposedCohortDefinition) # Exposed after prior outcome check
      
      # --- 6b. Perform Matching for this Pair ---
      matchingResult <- performPairMatching(
        exposedCohortDefinition = exposedCohortDefinition,
        controlsPoolBaseOutcome = controlsPoolBaseOutcome,
        exposureDatesCurrentExposure = exposureDatesCurrentExposure,
        matchRatio = matchRatio,
        exposureId = exposureId,
        outcomeId = outcomeId,
        session = session
      )
      
      matchedDataFinal <- matchingResult$matchedData
      nExposedMatched <- matchingResult$nMatchedExposed
      
      # Check if matching was successful
      if (is.null(matchedDataFinal) || nrow(matchedDataFinal) == 0) {
        removeNotification(id = procPairNotifId, session = session)
        on.exit(NULL) # Clear the specific on.exit for this pair notification
        next # Skip survival calculation if no sets
      }
      # Matching complete notification shown by helper
      
      # --- 6c. Calculate Survival for this Matched Pair ---
      survivalDataCurrentPair <- calculatePairSurvival(
        matchedDataFinal = matchedDataFinal,
        cohortBaseForOutcome = cohortBaseForOutcome,
        outcomeDatesCurrentOutcome = outcomeDatesCurrentOutcome,
        session = session
      )
      
      # --- 6d. Store Results if Survival Data is Valid ---
      # Check if the returned tibble is valid (not NULL) and has rows
      if (!is.null(survivalDataCurrentPair) && nrow(survivalDataCurrentPair) > 0) {
        # Lookup labels, provide fallback if not found
        exposureLabel <- conceptLabelLookup$concept_name_id[conceptLabelLookup$concept_id == exposureId][1]
        outcomeLabel <- conceptLabelLookup$concept_name_id[conceptLabelLookup$concept_id == outcomeId][1]
        exposureLabel <- ifelse(is.na(exposureLabel) || length(exposureLabel)==0, paste("Exposure ID:", exposureId), exposureLabel)
        outcomeLabel <- ifelse(is.na(outcomeLabel) || length(outcomeLabel)==0, paste("Outcome ID:", outcomeId), outcomeLabel)
        
        # Store results
        resultsList[[uniquePairKey]] <- list(
          survivalData = survivalDataCurrentPair,
          exposureId = exposureId, outcomeId = outcomeId,
          exposureLabel = exposureLabel, outcomeLabel = outcomeLabel,
          nExposedIncludedInMatching = nExposedIdentifiedInitial,
          nExposedMatched = nExposedMatched,
          nUnexposedMatched = sum(survivalDataCurrentPair$exposure_status == 0),
          nTotalPersonsInAnalysis = nrow(survivalDataCurrentPair)
        )
        showNotification(paste("Survival results processed for Exposure:", exposureIdStr, "Outcome:", outcomeIdStr), duration = 3, type = "message", session = session)
      }
      
      # Remove the notification for this specific pair after processing it
      removeNotification(id = procPairNotifId, session = session)
      on.exit(NULL) # Clear the specific on.exit handler for this pair's notification
      
    } # End inner loop (exposures)
  } # End outer loop (outcomes)
  
  # --- 7. Final Check and Return ---
  removeNotification(id = procMainId, session = session) # Remove the main processing notification manually
  on.exit(NULL) # Clear the main on.exit handler
  
  if (length(resultsList) == 0) {
    showNotification("Processing complete, but no valid results could be generated for any exposure-outcome pair.", type="warning", duration = 10, session = session)
    return(NULL)
  } else {
    showNotification(paste("Incidence Density Matching complete. Results generated for", length(resultsList), "pairs."), type="message", duration = 8, session = session)
    return(resultsList)
  }
}